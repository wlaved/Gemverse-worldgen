<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Gemverse 3D World Generator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.157.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.157.0/examples/jsm/"
        }
    }
    </script>
    <style>
        body { font-family: 'Inter', sans-serif; background-color: #111827; color: #d1d5db; touch-action: none; }
        .card { background-color: #1f2937; border: 1px solid #374151; border-radius: 0.75rem; }
        .loader { border: 4px solid #374151; border-top: 4px solid #4f46e5; border-radius: 50%; width: 40px; height: 40px; animation: spin 1s linear infinite; }
        #worldCanvas { cursor: grab; width: 100%; height: 100%; }
        #controls-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.7); color: white; display: flex; flex-direction: column; justify-content: center; align-items: center; text-align: center; padding: 1rem; border-radius: 0.5rem; pointer-events: none; opacity: 0; transition: opacity 0.3s; }
        #controls-overlay.visible { pointer-events: auto; opacity: 1; }
        #controls-overlay p { margin-bottom: 0.5rem; }
        #controls-overlay kbd { background-color: #374151; border-radius: 0.25rem; padding: 0.2rem 0.5rem; font-family: monospace; border: 1px solid #4b5563; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        
        #joystick-container { position: absolute; bottom: 20px; left: 20px; width: 120px; height: 120px; display: none; }
        #joystick-base { position: absolute; width: 100%; height: 100%; background: rgba(55, 65, 81, 0.5); border-radius: 50%; }
        #joystick-stick { position: absolute; top: 30px; left: 30px; width: 60px; height: 60px; background: rgba(107, 114, 128, 0.8); border-radius: 50%; }
    </style>
</head>
<body class="p-4 md:p-8">

    <div class="max-w-7xl mx-auto">
        <header class="text-center mb-8">
            <h1 class="text-4xl md:text-5xl font-bold text-white">Gemverse 3D World Generator</h1>
            <p class="mt-2 text-lg text-gray-400">Featuring planetary cube gravity, procedural biomes, and unique block colors.</p>
        </header>

        <main class="flex flex-col lg:flex-row gap-8">
            <div class="lg:w-1/3 w-full flex-shrink-0 card p-6 h-fit">
                <div class="space-y-6">
                    <div>
                        <label for="seedInput" class="block text-sm font-medium text-gray-300 mb-2">World Name / Seed (leave blank to use custom options)</label>
                        <div class="flex gap-2">
                            <input type="text" id="seedInput" class="w-full bg-gray-900 border border-gray-700 rounded-lg px-4 py-2 text-white focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 outline-none transition" placeholder="e.g., Olympus">
                            <button id="generateButton" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-lg transition-colors duration-200">Generate</button>
                        </div>
                    </div>

                    <div class="pt-4 border-t border-gray-700">
                        <button id="toggleCustomButton" class="w-full text-left font-medium text-white mb-2">Customize World ▼</button>
                        <div id="customOptions" class="space-y-4 hidden">
                             <div>
                                <label for="worldTypeSelect" class="block text-sm font-medium text-gray-300 mb-1">Dominant Biome</label>
                                <select id="worldTypeSelect" class="w-full bg-gray-900 border border-gray-700 rounded-lg px-4 py-2 text-white focus:ring-2 focus:ring-indigo-500 outline-none">
                                    <option value="Any">Any</option>
                                    <option value="Terra">Terra</option>
                                    <option value="Volcanic">Volcanic</option>
                                    <option value="Tropical">Tropical</option>
                                    <option value="Sky">Floating Islands</option>
                                    <option value="Alien">Alien</option>
                                    <option value="Hollow">Hollow</option>
                                </select>
                             </div>
                              <div>
                                <label for="worldSizeSelect" class="block text-sm font-medium text-gray-300 mb-1">World Size</label>
                                <select id="worldSizeSelect" class="w-full bg-gray-900 border border-gray-700 rounded-lg px-4 py-2 text-white focus:ring-2 focus:ring-indigo-500 outline-none">
                                    <option>Any</option>
                                    <option>Small</option>
                                    <option>Medium</option>
                                    <option>Large</option>
                                    <option>Colossal</option>
                                </select>
                             </div>
                        </div>
                    </div>

                    <div id="worldInfo" class="space-y-4 pt-4 border-t border-gray-700"></div>
                </div>
            </div>
            <div id="canvas-container" class="lg:w-2/3 w-full card p-2 flex items-center justify-center aspect-video relative">
                 <div id="loader" class="loader absolute z-10"></div>
                 <div id="controls-overlay" class="z-20 visible">
                    <h3 class="text-2xl font-bold mb-2">Planetary Gravity Explorer</h3>
                    <p id="desktop-instructions">Gravity pulls you to the center of the world! Walk over edges to shift orientation.<br>Click/Drag or <kbd>←</kbd><kbd>↑</kbd><kbd>→</kbd><kbd>↓</kbd> to look. <kbd>W</kbd><kbd>A</kbd><kbd>S</kbd><kbd>D</kbd> to move. <br> <kbd>F</kbd> to Fly. <kbd>Space</kbd> to Jump/Ascend. <kbd>Shift</kbd> to Descend.</p>
                    <p id="mobile-instructions" style="display: none;">Drag screen to look. Use joystick to move. Tap right-side to jump.</p>
                 </div>
                 <canvas id="worldCanvas"></canvas>
                 <div id="joystick-container">
                    <div id="joystick-base"></div>
                    <div id="joystick-stick"></div>
                 </div>
            </div>
        </main>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>
    <script type="module">
        import * as THREE from 'three';
        import { mergeGeometries } from 'three/addons/utils/BufferGeometryUtils.js';
        import { createNoise2D, createNoise3D } from 'https://cdn.skypack.dev/simplex-noise';

        const seedInput = document.getElementById('seedInput');
        const generateButton = document.getElementById('generateButton');
        const worldInfo = document.getElementById('worldInfo');
        const loader = document.getElementById('loader');
        const canvasContainer = document.getElementById('canvas-container');
        const worldCanvas = document.getElementById('worldCanvas');
        const controlsOverlay = document.getElementById('controls-overlay');
        const toggleCustomButton = document.getElementById('toggleCustomButton');
        const customOptions = document.getElementById('customOptions');
        const worldTypeSelect = document.getElementById('worldTypeSelect');
        const worldSizeSelect = document.getElementById('worldSizeSelect');

        let scene, camera, renderer, cannonWorld, playerBody;
        let clock = new THREE.Clock();
        let currentSeedString = 'Arcadia';
        
        let worldChunks = {};
        let noise = {};
        let worldParams = {};
        let worldMaterials = {};
        let lastPlayerChunk = {x: null, y: null, z: null};
        let chunkUpdateInterval = 0;
        let canJump = false;
        let overlayIsVisible = true;
        let isFlying = false;

        const CHUNK_SIZE = 32; 
        const VIEW_DISTANCE = 1;
        const GRAVITY_DEAD_ZONE_HALF_SIZE = 4.5;
        
        const BLOCK = { 
            AIR: 0, STONE: 1, DIRT: 2, GRASS: 3, SAND: 4, WATER: 5, 
            BASALT: 6, OBSIDIAN: 7, LAVA: 8, MUSHROOM_STEM: 9, MUSHROOM_GLOW: 10,
            GOLD_ORE: 11, GEM_ORE: 12, WOOD: 13, LEAVES: 14,
        };
        
        const facePositions = [
            { dir: [ -1,  0,  0 ], corners: [ [ 0, 1, 0 ], [ 0, 0, 0 ], [ 0, 1, 1 ], [ 0, 0, 1 ] ] },
            { dir: [  1,  0,  0 ], corners: [ [ 1, 1, 1 ], [ 1, 0, 1 ], [ 1, 1, 0 ], [ 1, 0, 0 ] ] },
            { dir: [  0, -1,  0 ], corners: [ [ 1, 0, 1 ], [ 0, 0, 1 ], [ 1, 0, 0 ], [ 0, 0, 0 ] ] },
            { dir: [  0,  1,  0 ], corners: [ [ 0, 1, 1 ], [ 1, 1, 1 ], [ 0, 1, 0 ], [ 1, 1, 0 ] ] },
            { dir: [  0,  0, -1 ], corners: [ [ 1, 1, 0 ], [ 1, 0, 0 ], [ 0, 1, 0 ], [ 0, 0, 0 ] ] },
            { dir: [  0,  0,  1 ], corners: [ [ 0, 1, 1 ], [ 0, 0, 1 ], [ 1, 1, 1 ], [ 1, 0, 1 ] ] },
        ];

        function createSeedFromString(str) { let h=0; for(let i=0;i<str.length;i++)h=((h<<5)-h)+str.charCodeAt(i),h|=0; return h; }
        function seededRandom(s) { return function() { s = Math.sin(s) * 10000; return s - Math.floor(s); } }

        function init() {
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x87CEEB, CHUNK_SIZE * (VIEW_DISTANCE * 2), CHUNK_SIZE * (VIEW_DISTANCE * 2 + 1));
            camera = new THREE.PerspectiveCamera(75, canvasContainer.clientWidth / canvasContainer.clientHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ canvas: worldCanvas, antialias: true });
            renderer.setSize(canvasContainer.clientWidth, canvasContainer.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            const ambientLight = new THREE.AmbientLight(0xb0c0d0, 1.5);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 2.5);
            directionalLight.position.set(1, 1, 0.5).normalize();
            scene.add(directionalLight);
            
            cannonWorld = new CANNON.World();
            cannonWorld.gravity.set(0, 0, 0);

            playerBody = new CANNON.Body({ mass: 5 });
            const cylinderShape = new CANNON.Cylinder(0.4, 0.4, 1.0, 8);
            playerBody.addShape(cylinderShape, new CANNON.Vec3(0, 0, 0));
            const sphereShape = new CANNON.Sphere(0.4);
            playerBody.addShape(sphereShape, new CANNON.Vec3(0, -0.5, 0));
            playerBody.fixedRotation = true;
            playerBody.updateMassProperties();

            playerBody.position.set(0, 50, 0);
            cannonWorld.addBody(playerBody);

            initControls();
            window.addEventListener('resize', () => {
                camera.aspect = canvasContainer.clientWidth / canvasContainer.clientHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(canvasContainer.clientWidth, canvasContainer.clientHeight);
            });
            animate();
        }
        
        function updateChunks() {
            const playerPos = playerBody.position;
            const currentChunkX = Math.floor(playerPos.x / CHUNK_SIZE);
            const currentChunkY = Math.floor(playerPos.y / CHUNK_SIZE);
            const currentChunkZ = Math.floor(playerPos.z / CHUNK_SIZE);

            if (currentChunkX === lastPlayerChunk.x && currentChunkY === lastPlayerChunk.y && currentChunkZ === lastPlayerChunk.z) return;
            
            loader.style.display = 'flex';
            const chunksToLoad = new Set();
            for (let x = currentChunkX - VIEW_DISTANCE; x <= currentChunkX + VIEW_DISTANCE; x++) {
                for (let y = currentChunkY - VIEW_DISTANCE; y <= currentChunkY + VIEW_DISTANCE; y++) {
                    for (let z = currentChunkZ - VIEW_DISTANCE; z <= currentChunkZ + VIEW_DISTANCE; z++) {
                        if (Math.abs(x * CHUNK_SIZE) > worldParams.worldBounds ||
                            Math.abs(y * CHUNK_SIZE) > worldParams.worldBounds ||
                            Math.abs(z * CHUNK_SIZE) > worldParams.worldBounds) continue;

                        chunksToLoad.add(`${x},${y},${z}`);
                    }
                }
            }
            
            for (const chunkId in worldChunks) {
                if (!chunksToLoad.has(chunkId)) {
                    scene.remove(worldChunks[chunkId].group);
                    cannonWorld.remove(worldChunks[chunkId].body);
                    worldChunks[chunkId].group.children.forEach(c => c.geometry.dispose());
                    delete worldChunks[chunkId];
                }
            }

            for (const chunkId of chunksToLoad) {
                if (!worldChunks[chunkId]) {
                    const [x, y, z] = chunkId.split(',').map(Number);
                    generateChunk(x, y, z);
                }
            }
            
            lastPlayerChunk = {x: currentChunkX, y: currentChunkY, z: currentChunkZ};
            loader.style.display = 'none';
            updateWorldInfo(currentSeedString, lastPlayerChunk);
        }
        function generateChunk(chunkX, chunkY, chunkZ) {
            const worldData = generateChunkData(chunkX, chunkY, chunkZ);
            const { geometries, physicsVertices, physicsIndices } = generateGeometryDataFromChunk(worldData);
            if (physicsVertices.length === 0) return;
            const chunkGroup = new THREE.Group();
            for (const blockType in geometries) {
                const mergedGeometry = mergeGeometries(geometries[blockType]);
                if (mergedGeometry) {
                    const mesh = new THREE.Mesh(mergedGeometry, worldMaterials[blockType]);
                    chunkGroup.add(mesh);
                }
            }
            const chunkPos = new THREE.Vector3(chunkX, chunkY, chunkZ).multiplyScalar(CHUNK_SIZE);
            chunkGroup.position.copy(chunkPos);
            scene.add(chunkGroup);

            const trimeshShape = new CANNON.Trimesh(physicsVertices, physicsIndices);
            const body = new CANNON.Body({ mass: 0 });
            body.addShape(trimeshShape);
            body.position.copy(chunkPos);
            cannonWorld.addBody(body);
            worldChunks[`${chunkX},${chunkY},${chunkZ}`] = { group: chunkGroup, body };
        }
        
        function generateChunkData(chunkX, chunkY, chunkZ) {
            const data = new Uint8Array(CHUNK_SIZE * CHUNK_SIZE * CHUNK_SIZE).fill(BLOCK.AIR);
            const get = (x,y,z) => (x<0||x>=CHUNK_SIZE||y<0||y>=CHUNK_SIZE||z<0||z>=CHUNK_SIZE) ? BLOCK.AIR : data[y*CHUNK_SIZE*CHUNK_SIZE+z*CHUNK_SIZE+x];
            const set = (x,y,z,t) => { if(x>=0&&x<CHUNK_SIZE&&y>=0&&y<CHUNK_SIZE&&z>=0&&z<CHUNK_SIZE) data[y*CHUNK_SIZE*CHUNK_SIZE+z*CHUNK_SIZE+x] = t; };
            
            const { densityScale, densityThreshold, liquidCoreSize, worldBounds, hollowRadius, biomes } = worldParams;

            for (let y = 0; y < CHUNK_SIZE; y++) {
                for (let x = 0; x < CHUNK_SIZE; x++) {
                    for (let z = 0; z < CHUNK_SIZE; z++) {
                        const globalX = chunkX * CHUNK_SIZE + x;
                        const globalY = chunkY * CHUNK_SIZE + y;
                        const globalZ = chunkZ * CHUNK_SIZE + z;
                        
                        if (Math.abs(globalX) > worldBounds || Math.abs(globalY) > worldBounds || Math.abs(globalZ) > worldBounds) continue;

                        let density = noise.density(globalX / densityScale, globalY / densityScale, globalZ / densityScale);
                        
                        if (biomes.has('SKY')) {
                             density += noise.island(globalX / 40, globalY / 30, globalZ / 40) * 1.5 - 0.75;
                        }

                        if (biomes.has('HOLLOW')) {
                             const dist = Math.sqrt(globalX*globalX + globalY*globalY + globalZ*globalZ);
                             if (dist < hollowRadius) continue;
                        }
                        
                        let block = BLOCK.AIR;
                        if (density > densityThreshold) {
                           block = biomes.has('VOLCANIC') ? BLOCK.BASALT : BLOCK.STONE;
                        }

                        if (block !== BLOCK.AIR) {
                             const caveNoise = noise.cave(globalX / 25, globalY / 25, globalZ / 25);
                             if (caveNoise > 0.65) {
                                 block = BLOCK.AIR;
                             }
                        }

                        if (block === BLOCK.STONE && globalY < worldBounds * 0.2) {
                            if (globalY < -worldBounds * 0.2 && Math.random() < 0.01) block = BLOCK.GEM_ORE;
                            else if (Math.random() < 0.02) block = BLOCK.GOLD_ORE;
                        }
                        
                        set(x, y, z, block);
                    }
                }
            }
            
            for (let x = 0; x < CHUNK_SIZE; x++) {
                for (let z = 0; z < CHUNK_SIZE; z++) {
                     for (let y = 0; y < CHUNK_SIZE; y++) {
                         const globalX = chunkX * CHUNK_SIZE + x;
                         const globalY = chunkY * CHUNK_SIZE + y;
                         const globalZ = chunkZ * CHUNK_SIZE + z;

                        if ( liquidCoreSize > 0 &&
                            Math.abs(globalX) < liquidCoreSize && Math.abs(globalY) < liquidCoreSize && Math.abs(globalZ) < liquidCoreSize &&
                            get(x, y, z) === BLOCK.AIR
                        ) {
                             const waterCaveNoise = noise.waterCave(globalX / 50, globalY / 50, globalZ / 50);
                             if(waterCaveNoise < 0.6) {
                                set(x,y,z, biomes.has('VOLCANIC') ? BLOCK.LAVA : BLOCK.WATER);
                                continue;
                             }
                        }
                        
                        let isSurface = false;
                        let isInnerSurface = false;
                        const myDist = Math.sqrt(globalX*globalX + globalY*globalY + globalZ*globalZ);
                        let surfaceNormal = null;

                        if (get(x,y,z) !== BLOCK.AIR && get(x,y,z) !== BLOCK.WATER && get(x,y,z) !== BLOCK.LAVA) {
                            for(const face of facePositions) {
                                if (get(x + face.dir[0], y + face.dir[1], z + face.dir[2]) === BLOCK.AIR) {
                                    isSurface = true;
                                    surfaceNormal = face.dir;
                                    const neighborDist = Math.sqrt(
                                        (globalX + face.dir[0])**2 +
                                        (globalY + face.dir[1])**2 +
                                        (globalZ + face.dir[2])**2
                                    );
                                    if (neighborDist < myDist) isInnerSurface = true;
                                    break;
                                }
                            }

                             if (isSurface) {
                                if (isInnerSurface && biomes.has('HOLLOW')) {
                                    if (get(x,y,z) === BLOCK.STONE && Math.random() < 0.05) {
                                        set(x,y,z, BLOCK.GEM_ORE);
                                    }
                                } else {
                                    const block = get(x,y,z);
                                    if ((block === BLOCK.STONE || block === BLOCK.DIRT)) {
                                        if (biomes.has('TERRA') || biomes.has('ALIEN') || biomes.has('SKY')) {
                                            set(x, y, z, BLOCK.GRASS);
                                        } else if (biomes.has('VOLCANIC') || biomes.has('HOLLOW')) {
                                            set(x, y, z, BLOCK.OBSIDIAN);
                                        } else if (biomes.has('TROPICAL')) {
                                            set(x, y, z, BLOCK.SAND);
                                        }
                                    }
                                
                                    if (get(x, y, z) === BLOCK.GRASS) {
                                        if (worldParams.treeChance && noise.feature(globalX / 10, globalZ / 10) > 0.7) {
                                            const height = 4 + Math.floor(noise.rand() * 3);
                                            for(let i=1; i <= height; i++) set(x + surfaceNormal[0]*i, y + surfaceNormal[1]*i, z + surfaceNormal[2]*i, BLOCK.WOOD);
                                            const radius = 2;
                                            const topX = x + surfaceNormal[0]*height;
                                            const topY = y + surfaceNormal[1]*height;
                                            const topZ = z + surfaceNormal[2]*height;

                                            for(let ly = -radius; ly <= radius; ly++) {
                                                for(let lx = -radius; lx <= radius; lx++) {
                                                    for(let lz = -radius; lz <= radius; lz++) {
                                                        if(Math.sqrt(lx*lx + ly*ly + lz*lz) <= radius) {
                                                            set(topX+lx, topY+ly, topZ+lz, BLOCK.LEAVES);
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    
                                    if (get(x,y,z) === BLOCK.STONE || get(x,y,z) === BLOCK.BASALT) {
                                        if (biomes.has('ALIEN') && noise.feature(globalX/8, globalZ/8) > 0.6) {
                                            const h = 3 + Math.floor(noise.rand() * 4);
                                            for(let i=1; i<=h; i++) set(x+surfaceNormal[0]*i, y+surfaceNormal[1]*i, z+surfaceNormal[2]*i, BLOCK.MUSHROOM_STEM);
                                            const radius = 1 + Math.floor(noise.rand() * 2);
                                            const topX = x + surfaceNormal[0]*h;
                                            const topY = y + surfaceNormal[1]*h;
                                            const topZ = z + surfaceNormal[2]*h;
                                            
                                            for(let ly = -radius; ly <= radius; ly++) {
                                                for(let lx = -radius; lx <= radius; lx++) {
                                                    for(let lz = -radius; lz <= radius; lz++) {
                                                        if(Math.sqrt(lx*lx+ly*ly+lz*lz) <= radius) {
                                                            set(topX+lx, topY+ly, topZ+lz, BLOCK.MUSHROOM_GLOW);
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            return data;
        }

        function generateGeometryDataFromChunk(chunkData) {
            const geometries = {};
            const physicsVertices = [];
            const physicsIndices = [];
            const getBlock = (x, y, z) => (x<0||x>=CHUNK_SIZE||y<0||y>=CHUNK_SIZE||z<0||z>=CHUNK_SIZE) ? BLOCK.AIR : chunkData[y*CHUNK_SIZE*CHUNK_SIZE+z*CHUNK_SIZE+x];
            for (let y = 0; y < CHUNK_SIZE; y++) {
                for (let z = 0; z < CHUNK_SIZE; z++) {
                    for (let x = 0; x < CHUNK_SIZE; x++) {
                        const blockType = getBlock(x, y, z);
                        if (blockType === BLOCK.AIR) continue;
                        for (const { dir, corners } of facePositions) {
                            const neighborType = getBlock(x + dir[0], y + dir[1], z + dir[2]);
                            if (neighborType === BLOCK.AIR || ((neighborType === BLOCK.WATER || neighborType === BLOCK.LEAVES) && blockType !== neighborType)) {
                                if (!geometries[blockType]) geometries[blockType] = [];
                                const ndx = physicsVertices.length / 3;
                                const positions = [];
                                for (const pos of corners) {
                                    positions.push(x + pos[0], y + pos[1], z + pos[2]);
                                    physicsVertices.push(x + pos[0], y + pos[1], z + pos[2]);
                                }
                                physicsIndices.push(ndx, ndx + 1, ndx + 2, ndx + 2, ndx + 1, ndx + 3);
                                const geometry = new THREE.BufferGeometry();
                                geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
                                geometry.setIndex([0, 1, 2, 2, 1, 3]);
                                geometry.computeVertexNormals();
                                geometries[blockType].push(geometry);
                            }
                        }
                    }
                }
            }
            return { geometries, physicsVertices, physicsIndices };
        }

        function updateWorldInfo(seed, { x, y, z }) {
            const worldSize = worldParams.worldBounds * 2;
            const p = playerBody.position;
            document.getElementById('worldInfo').innerHTML = `
                <h3 class="text-xl font-bold text-white">World: <span class="text-indigo-400">${seed}</span></h3>
                <div class="grid grid-cols-1 gap-4 text-sm">
                    <div class="bg-gray-900 p-3 rounded-lg"><p class="font-semibold text-gray-400">World Description</p><p class="text-lg text-white">${worldParams.typeName}</p></div>
                    <div class="bg-gray-900 p-3 rounded-lg"><p class="font-semibold text-gray-400">World Size</p><p class="text-lg text-white">${worldParams.worldSizeName} (~${worldSize}x${worldSize}x${worldSize})</p></div>
                    <div class="bg-gray-900 p-3 rounded-lg"><p class="font-semibold text-gray-400">Player Chunk (X,Y,Z)</p><p class="text-lg text-white">${x}, ${y}, ${z}</p></div>
                    <div class="bg-gray-900 p-3 rounded-lg"><p class="font-semibold text-gray-400">Player Coords (X,Y,Z)</p><p class="text-lg text-white">${p.x.toFixed(1)}, ${p.y.toFixed(1)}, ${p.z.toFixed(1)}</p></div>
                </div>`;
        }
        
        const movement = { x: 0, z: 0 };
        function hideOverlayOnce() { if (!overlayIsVisible) return; controlsOverlay.classList.remove('visible'); overlayIsVisible = false; }
        function initControls() {
            const isTouchDevice = 'ontouchstart' in window;
            const joystickContainer = document.getElementById('joystick-container');
            const joystickStick = document.getElementById('joystick-stick');
            if (isTouchDevice) {
                document.getElementById('desktop-instructions').style.display = 'none';
                document.getElementById('mobile-instructions').style.display = 'block';
                joystickContainer.style.display = 'block';
                canvasContainer.addEventListener('touchstart', (e) => {
                    if (e.target === worldCanvas && e.touches.length === 1) {
                        const touch = e.touches[0];
                        if (touch.clientX > window.innerWidth / 2) {
                             if (canJump) { playerBody.velocity.y = 9; canJump = false; }
                        }
                    }
                });
                let joystickTouchId = null;
                joystickContainer.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    joystickTouchId = e.changedTouches[0].identifier;
                    hideOverlayOnce();
                }, { passive: false });
                window.addEventListener('touchmove', (e) => {
                     for (let i = 0; i < e.changedTouches.length; i++) {
                        const touch = e.changedTouches[i];
                        if (touch.identifier === joystickTouchId) {
                            const rect = joystickContainer.getBoundingClientRect();
                            const x = (touch.clientX - rect.left - 60) / 60;
                            const y = (touch.clientY - rect.top - 60) / 60;
                            const mag = Math.sqrt(x*x + y*y);
                            if (mag > 1) { movement.x = x / mag; movement.z = y / mag; } else { movement.x = x; movement.z = y; }
                            joystickStick.style.transform = `translate(${movement.x * 30}px, ${movement.z * 30}px)`;
                        } else { handleLook(e.changedTouches[i]); }
                    }
                }, { passive: false });
                window.addEventListener('touchend', (e) => {
                    for (let i = 0; i < e.changedTouches.length; i++) {
                        if (e.changedTouches[i].identifier === joystickTouchId) {
                            joystickTouchId = null;
                            movement.x = 0; movement.z = 0;
                            joystickStick.style.transform = `translate(0px, 0px)`;
                        }
                    }
                });
            } else {
                let isMouseDown = false;
                worldCanvas.addEventListener('mousedown', (e) => { isMouseDown = true; hideOverlayOnce(); });
                window.addEventListener('mouseup', (e) => { isMouseDown = false; });
                window.addEventListener('mousemove', (e) => { if (isMouseDown) handleLook(e); });
            }
        }
        
        let pitch = 0;
        let yaw = 0;
        function handleLook(e) {
            const moveX = e.movementX || (e.touches ? e.touches[0].pageX - (window.lastX || e.touches[0].pageX) : 0);
            const moveY = e.movementY || (e.touches ? e.touches[0].pageY - (window.lastY || e.touches[0].pageY) : 0);
            
            yaw -= moveX * 0.002;
            pitch -= moveY * 0.002;
            pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, pitch));

            if (e.touches) { window.lastX = e.touches[0].pageX; window.lastY = e.touches[0].pageY; }
        }
        function handleKeyboardLook(delta) {
            const lookSpeed = 1.5;
            if (window.keys.ArrowUp) pitch += lookSpeed * delta;
            if (window.keys.ArrowDown) pitch -= lookSpeed * delta;
            if (window.keys.ArrowLeft) yaw += lookSpeed * delta;
            if (window.keys.ArrowRight) yaw -= lookSpeed * delta;
            pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, pitch));
        }

        const forwardVec = new THREE.Vector3();
        const rightVec = new THREE.Vector3();
        const worldVelocity = new THREE.Vector3();
        let currentUp = new THREE.Vector3(0,1,0);

        function handleControls() {
            const speed = 5;
            const moveX = movement.x || (window.keys.KeyD ? 1 : 0) - (window.keys.KeyA ? 1 : 0);
            const moveZ = movement.z || (window.keys.KeyW ? 1 : 0) - (window.keys.KeyS ? 1 : 0);
            
            const upQuat = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0,1,0), currentUp);
            const yawQuat = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0,1,0), yaw);
            const pitchQuat = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1,0,0), pitch);
            
            camera.quaternion.copy(upQuat).multiply(yawQuat).multiply(pitchQuat);
            
            camera.getWorldDirection(forwardVec);
            rightVec.crossVectors(forwardVec, currentUp).normalize();
            const forwardOnPlane = new THREE.Vector3().crossVectors(currentUp, rightVec);

            worldVelocity.set(0,0,0);
            worldVelocity.add(forwardOnPlane.multiplyScalar(moveZ));
            worldVelocity.add(rightVec.multiplyScalar(moveX));

            if (worldVelocity.length() > 0) worldVelocity.normalize().multiplyScalar(speed);
            
            const upVec = new CANNON.Vec3(currentUp.x, currentUp.y, currentUp.z);
            let verticalComponent = new CANNON.Vec3();
            if(!isFlying) {
                const dot = playerBody.velocity.dot(upVec);
                verticalComponent = upVec.scale(dot);
            }
            const newVelocity = new CANNON.Vec3(worldVelocity.x, worldVelocity.y, worldVelocity.z).vadd(verticalComponent);
            playerBody.velocity.copy(newVelocity);

            if (isFlying) {
                let moveY = 0;
                if (window.keys.Space) moveY = speed;
                if (window.keys.ShiftLeft) moveY = -speed;
                const flyVertical = new CANNON.Vec3(currentUp.x, currentUp.y, currentUp.z).scale(moveY);
                playerBody.velocity.copy(worldVelocity).vadd(flyVertical, playerBody.velocity);
            } else {
                const contactPoint = new CANNON.Vec3(playerBody.position.x, playerBody.position.y, playerBody.position.z).vsub(upVec.scale(1.1));
                const result = new CANNON.RaycastResult();
                canJump = cannonWorld.raycastClosest(playerBody.position, contactPoint, {}, result);
                if (window.keys.Space && canJump) {
                    const jumpImpulse = upVec.scale(9);
                    playerBody.velocity.vadd(jumpImpulse, playerBody.velocity);
                }
            }
        }

        function animate() {
            const delta = Math.min(clock.getDelta(), 0.1);
            requestAnimationFrame(animate);

            const pos = playerBody.position;
            const absX = Math.abs(pos.x), absY = Math.abs(pos.y), absZ = Math.abs(pos.z);
            const gravityForce = new CANNON.Vec3(0,0,0);
            const targetUp = new THREE.Vector3(0,1,0);
        
            const inDeadZone = absX < GRAVITY_DEAD_ZONE_HALF_SIZE && absY < GRAVITY_DEAD_ZONE_HALF_SIZE && absZ < GRAVITY_DEAD_ZONE_HALF_SIZE;

            if (!inDeadZone) {
                if (absY >= absX && absY >= absZ) {
                    if(!isFlying) gravityForce.y = -Math.sign(pos.y) * 20 * playerBody.mass;
                    targetUp.set(0, Math.sign(pos.y), 0);
                } else if (absX >= absY && absX >= absZ) {
                    if(!isFlying) gravityForce.x = -Math.sign(pos.x) * 20 * playerBody.mass;
                    targetUp.set(Math.sign(pos.x), 0, 0);
                } else {
                    if(!isFlying) gravityForce.z = -Math.sign(pos.z) * 20 * playerBody.mass;
                    targetUp.set(0, 0, Math.sign(pos.z));
                }
                currentUp.lerp(targetUp, 0.1).normalize();
            }

            if (!isFlying) {
                playerBody.applyForce(gravityForce, playerBody.position);
            }
            
            cannonWorld.step(1/60, delta, 5);
            handleKeyboardLook(delta);
            handleControls();
            camera.position.copy(playerBody.position);
            chunkUpdateInterval += delta;
            if (chunkUpdateInterval > 0.25) { updateChunks(); chunkUpdateInterval = 0; }
            renderer.render(scene, camera);
        }

        function generateWorldMaterials(colors) {
            const mats = {};
            for (const blockId in colors) {
                const color = colors[blockId];
                const params = { color };
                const id = Number(blockId);

                if (id === BLOCK.WATER || id === BLOCK.LEAVES) {
                    params.transparent = true;
                    params.opacity = id === BLOCK.LEAVES ? 0.8 : 0.6;
                } else if (id === BLOCK.LAVA || id === BLOCK.MUSHROOM_GLOW || id === BLOCK.GEM_ORE) {
                    params.emissive = new THREE.Color(color).multiplyScalar(1.2);
                }
                mats[id] = new THREE.MeshLambertMaterial(params);
            }
            return mats;
        }

        function getWorldParams(seed, overrides = {}) {
            const rand = seededRandom(createSeedFromString(seed));
            const colors = {};
            const biomes = new Set();

            const typeKey = overrides.worldType && overrides.worldType !== 'Any' ? overrides.worldType : null;
            let worldSizeName = overrides.worldSize && overrides.worldSize !== 'Any' ? overrides.worldSize : null;
            let worldBounds;

            if (!worldSizeName) {
                const sizeVal = rand();
                if (sizeVal < 0.05) { worldSizeName = 'Colossal'; } 
                else if (sizeVal < 0.20) { worldSizeName = 'Large'; } 
                else if (sizeVal < 0.55) { worldSizeName = 'Medium'; } 
                else { worldSizeName = 'Small'; }
            }
            
            switch(worldSizeName) {
                case 'Colossal': worldBounds = 1000; break;
                case 'Large': worldBounds = 400; break;
                case 'Medium': worldBounds = 200; break;
                case 'Small': worldBounds = 100; break;
            }

            const biomeScores = {
                Volcanic: rand(), Tropical: rand(), Sky: rand(),
                Alien: rand(), Hollow: rand(), Terra: rand(),
            };

            if (typeKey && biomeScores[typeKey]) {
                biomeScores[typeKey] = 1.1; // Force dominant
            }
            
            if (worldSizeName === 'Colossal') {
                for (const key in biomeScores) biomeScores[key] += 0.5;
            }

            let dominantBiome = 'Terra';
            let maxScore = 0;
            for (const biome in biomeScores) {
                if (biomeScores[biome] > maxScore) {
                    maxScore = biomeScores[biome];
                    dominantBiome = biome;
                }
            }
            biomes.add(dominantBiome.toUpperCase());

            for (const biome in biomeScores) {
                if (biome !== dominantBiome && biomeScores[biome] > 0.7) {
                    biomes.add(biome.toUpperCase());
                }
            }

            let params = {};
            
            switch(dominantBiome) {
                case 'Volcanic':
                    params = { densityScale: 40, densityThreshold: 0.1, liquidCoreSize: worldBounds * 0.25 };
                    colors[BLOCK.BASALT] = new THREE.Color().setHSL(rand(), 0.2, 0.1 + rand() * 0.2);
                    colors[BLOCK.OBSIDIAN] = new THREE.Color().setHSL(rand(), 0.1, 0.05 + rand() * 0.15);
                    colors[BLOCK.LAVA] = new THREE.Color().setHSL(0.05 + rand()*0.05, 1, 0.6);
                    break;
                case 'Tropical':
                    params = { densityScale: 35, densityThreshold: 0.15, liquidCoreSize: worldBounds * 0.4, treeChance: 0.005 };
                    colors[BLOCK.GRASS] = new THREE.Color().setHSL(0.25 + rand()*0.15, 0.8, 0.5 + rand()*0.1);
                    colors[BLOCK.SAND] = new THREE.Color().setHSL(0.15, 0.9, 0.7 + rand()*0.1);
                    colors[BLOCK.WATER] = new THREE.Color().setHSL(0.55 + rand()*0.1, 0.9, 0.5);
                    break;
                case 'Sky':
                    params = { densityScale: 45, densityThreshold: 0.25, liquidCoreSize: 0, hasFloatingIslands: true, treeChance: 0.01 };
                    colors[BLOCK.STONE] = new THREE.Color().setHSL(rand(), 0.2, 0.6 + rand()*0.1);
                    colors[BLOCK.GRASS] = new THREE.Color().setHSL(0.3 + rand()*0.2, 0.8, 0.6);
                    colors[BLOCK.DIRT] = new THREE.Color(0x9b7653).lerp(colors[BLOCK.STONE], 0.4);
                    break;
                case 'Alien':
                    params = { densityScale: 35, densityThreshold: 0.3, liquidCoreSize: 0 };
                    colors[BLOCK.STONE] = new THREE.Color().setHSL(0.7 + rand()*0.3, 0.4, 0.3);
                    colors[BLOCK.MUSHROOM_STEM] = new THREE.Color().setHSL(rand(), 0.2, 0.9);
                    colors[BLOCK.MUSHROOM_GLOW] = new THREE.Color().setHSL(rand(), 1, 0.7);
                    break;
                case 'Hollow':
                    params = { densityScale: 60, densityThreshold: 0.1, liquidCoreSize: 0, hollowRadius: worldBounds * 0.8 };
                    colors[BLOCK.OBSIDIAN] = new THREE.Color().setHSL(rand(), 0.3, 0.15);
                    colors[BLOCK.STONE] = new THREE.Color().setHSL(rand(), 0.2, 0.5);
                    break;
                default:
                    dominantBiome = 'Terra';
                    params = { densityScale: 50, densityThreshold: 0.1, liquidCoreSize: 0, hasFloatingIslands: rand() > 0.7, treeChance: 0.01 };
                    colors[BLOCK.STONE] = new THREE.Color().setHSL(0.1, 0.1, 0.4 + rand()*0.2);
                    colors[BLOCK.DIRT] = new THREE.Color(0x9b7653).lerp(colors[BLOCK.STONE], 0.6);
                    colors[BLOCK.GRASS] = new THREE.Color().setHSL(0.3, 0.7, 0.5 + rand()*0.1);
                    break;
            }

            let typeName = dominantBiome;
            const additions = [];
            biomes.forEach(b => {
                const bLower = b.charAt(0) + b.slice(1).toLowerCase();
                if (bLower !== dominantBiome) additions.push(bLower);
            });
            if (additions.length > 0) {
                typeName += ` with ${additions.join(', ')}`;
            }
            
            if (!colors[BLOCK.STONE]) colors[BLOCK.STONE] = new THREE.Color(0x808080);
            if (!colors[BLOCK.DIRT]) colors[BLOCK.DIRT] = new THREE.Color(0x9b7653);
            if (!colors[BLOCK.GRASS]) colors[BLOCK.GRASS] = new THREE.Color(0x22c55e);
            if (!colors[BLOCK.SAND]) colors[BLOCK.SAND] = new THREE.Color(0xfde047);
            if (!colors[BLOCK.WATER]) colors[BLOCK.WATER] = new THREE.Color(0x3b82f6);
            if (!colors[BLOCK.OBSIDIAN]) colors[BLOCK.OBSIDIAN] = new THREE.Color(0x1e1b26);
            colors[BLOCK.WOOD] = new THREE.Color().setHSL(0.08 + rand() * 0.04, 0.5, 0.3 + rand() * 0.2);
            colors[BLOCK.LEAVES] = new THREE.Color().setHSL(biomes.has('ALIEN') ? rand() : 0.3 + rand()*0.1, 0.8, 0.5 + rand()*0.2);
            colors[BLOCK.GOLD_ORE] = new THREE.Color(0xfacc15);
            colors[BLOCK.GEM_ORE] = new THREE.Color(0x22d3ee);

            return { ...params, typeName, worldSizeName, worldBounds, colors, biomes };
        }

        function startNewWorld(seed, overrides) {
            currentSeedString = seed;
            loader.style.display = 'flex';
            
            controlsOverlay.classList.add('visible');
            overlayIsVisible = true;
            isFlying = false;
            
            for(const chunkId in worldChunks) {
                worldChunks[chunkId].group.children.forEach(c => { c.geometry.dispose(); });
                scene.remove(worldChunks[chunkId].group);
                cannonWorld.remove(worldChunks[chunkId].body);
            }
            worldChunks = {};
            lastPlayerChunk = {x: null, y: null, z: null};

            const numericalSeed = createSeedFromString(seed);
            
            noise.density = createNoise3D(seededRandom(numericalSeed + 2));
            noise.island = createNoise3D(seededRandom(numericalSeed + 3));
            noise.feature = createNoise2D(seededRandom(numericalSeed + 4));
            noise.cave = createNoise3D(seededRandom(numericalSeed + 5));
            noise.waterCave = createNoise3D(seededRandom(numericalSeed + 6));
            noise.rand = seededRandom(numericalSeed + 7); // For features
            worldParams = getWorldParams(seed, overrides);
            worldMaterials = generateWorldMaterials(worldParams.colors);

            scene.background = new THREE.Color(worldParams.biomes.has('VOLCANIC') || worldParams.biomes.has('HOLLOW') ? 0x111827 : 0x87CEEB);
            scene.fog.color.copy(scene.background);
            camera.up.set(0,1,0);
            currentUp.set(0,1,0);
            pitch = 0;
            yaw = 0;

            playerBody.position.set(0, worldParams.worldBounds + 10, 0);
            playerBody.velocity.set(0,0,0);
            
            updateChunks();
        }

        toggleCustomButton.addEventListener('click', () => {
            customOptions.classList.toggle('hidden');
            toggleCustomButton.textContent = customOptions.classList.contains('hidden') ? 'Customize World ▼' : 'Customize World ▲';
        });

        window.keys = {};
        window.addEventListener('keydown', (e) => {
            window.keys[e.code] = true;
            hideOverlayOnce();
            if (e.code === 'KeyF') {
                isFlying = !isFlying;
            }
        });
        window.addEventListener('keyup', (e) => (window.keys[e.code] = false));
        
        function handleGenerateClick() {
             let seed = seedInput.value.trim();
             const overrides = {};
             if (!seed) {
                 seed = Math.random().toString(36).substring(2, 10);
                 seedInput.value = seed;
                 overrides.worldType = worldTypeSelect.value;
                 overrides.worldSize = worldSizeSelect.value;
             }
             startNewWorld(seed, overrides);
        }

        generateButton.addEventListener('click', handleGenerateClick);
        seedInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') handleGenerateClick();
        });

        window.onload = () => {
            init();
            startNewWorld('Olympus');
        };
    </script>
</body>
</html>


